# Разработка системы гибких колонок для Todo-приложения

## Введение: Зачем нужна эта документация?

Сейчас в приложении жестко закодированы две колонки: "Активные" и "Завершённые". Задачи определяются булевым полем `completed`. Это работает, но не масштабируется. Что если нужны колонки "Запланировано", "В работе", "На проверке", "Завершено"?

Эта документация объясняет, как переделать архитектуру приложения, чтобы поддерживать произвольное количество колонок с произвольными названиями.

---

## Часть 1: Анализ текущей архитектуры и её ограничения

### Как устроено приложение сейчас

Приложение построено по классической React-архитектуре с компонентной иерархией:

```
TasksFetch (контейнер с состоянием и бизнес-логикой)
  ↓
TaskList (презентационный компонент для списка)
  ↓
Task (презентационный компонент для одной задачи)
```

**Ключевое состояние находится в `TasksFetch.tsx`:**
- `todos: Todo[]` - массив всех задач
- `activeTasks` и `completedTasks` - вычисляемые массивы через фильтрацию по `task.completed`

### Фундаментальная проблема: Boolean как модель состояния

Посмотрим на интерфейс `Todo`:

```typescript
export interface Todo {
  userId: number;
  id: number;
  title: string;
  completed: boolean;  // ← Корень проблемы
  user?: User;
}
```

**Почему `completed: boolean` это проблема?**

Boolean имеет только два возможных значения: `true` и `false`. Это моделирует **бинарное состояние** - задача либо завершена, либо нет.

Когда мы хотим добавить третье состояние (например, "На проверке"), boolean перестает работать. Технически можно использовать трюки вроде:
- Добавить второй boolean: `inReview: boolean`
- Использовать числа: `status: 0 | 1 | 2`

Но это антипаттерны, которые приводят к:
- **Проблемам масштабирования** - для 5 колонок нужно 5 boolean-полей
- **Рассинхронизации данных** - что если `completed: true` и `inReview: true` одновременно?
- **Сложности в коде** - множество `if/else` для проверки всех комбинаций

### Правильная модель: Enum-подобная структура

Вместо boolean нужна модель, которая представляет **один выбор из множества вариантов**:

```typescript
columnId: string  // Может быть 'progress', 'review', 'completed', 'archived', и т.д.
```

Это называется "discriminated union" или "enum" в других языках. Задача всегда находится ровно в одной колонке, и это явно выражено в данных.

**Преимущества такой модели:**
- Произвольное количество состояний
- Невозможность рассинхронизации (задача не может быть одновременно "в работе" и "завершена")
- Простота проверок: `task.columnId === 'completed'` вместо комбинаций boolean-ов
- Легкость расширения - добавление новой колонки не требует изменения интерфейса

---

## Часть 2: Проектирование новой модели данных

### 2.1. Концепция "Колонка" как сущность

Раньше колонки были неявными - они существовали только в JSX как два компонента `<TaskList>`. Теперь колонка должна стать **первоклассной сущностью** с собственной моделью данных.

**Что определяет колонку?**
- **Идентификатор** - уникальный ID для программной работы
- **Название** - то, что видит пользователь
- **Порядок** - где колонка отображается на экране

Отсюда интерфейс:

```typescript
export interface Column {
  id: string;       // 'progress', 'review', 'completed'
  title: string;    // 'В работе', 'На проверке', 'Завершено'
  order: number;    // 0, 1, 2... (определяет порядок слева направо)
}
```

**Почему `id: string`, а не `id: number`?**

String ID имеют несколько преимуществ:
1. **Семантичность** - `columnId: 'review'` понятнее, чем `columnId: 2`
2. **Независимость от порядка** - можно менять `order`, не меняя ID
3. **Использование как ключи** - удобно для объектов типа `Record<string, Todo[]>`
4. **Миграция данных** - при изменении порядка колонок не нужно обновлять все задачи

### 2.2. Связь между задачами и колонками

После введения колонок как сущности, задачи должны **ссылаться** на колонку через её ID:

```typescript
export interface Todo {
  userId: number;
  id: number;
  title: string;
  columnId: string;  // Ссылка на Column.id
  user?: User;
}
```

Это создает связь "один-ко-многим": одна колонка содержит много задач.

**Важный вопрос:** Почему не хранить массив задач внутри колонки?

```typescript
// ❌ Альтернативный, но плохой подход
export interface Column {
  id: string;
  title: string;
  tasks: Todo[];  // Храним задачи в колонке
}
```

**Проблемы этого подхода:**
- **Нормализация данных** - задача принадлежит одной колонке, но может иметь другие связи (пользователь, теги)
- **Сложность перемещения** - переместить задачу = удалить из одного массива + добавить в другой
- **Фильтрация и поиск** - чтобы найти задачу, нужно обходить все колонки
- **Конфликты при обновлениях** - если обновляем задачу, нужно найти правильную колонку

**Правильный подход (который мы используем):**
```typescript
// Колонки - отдельно
columns: Column[]

// Задачи - отдельно, со ссылкой на колонку
todos: Todo[]  // каждая имеет columnId

// Связь восстанавливается через фильтрацию
todosInColumn = todos.filter(t => t.columnId === column.id)
```

Это называется "нормализация данных" - каждая сущность хранится в одном месте, связи выражены через ID.

---

## Часть 3: Проблема интеграции с внешним API

### 3.1. Несоответствие моделей данных

Наше приложение использует JSONPlaceholder API, который возвращает:

```typescript
{
  id: 1,
  title: "Задача",
  completed: boolean,  // API использует старую модель!
  userId: 1
}
```

Но мы хотим работать с:

```typescript
{
  id: 1,
  title: "Задача",
  columnId: string,  // Наша новая модель
  userId: 1
}
```

Это классическая проблема: **внешняя система использует другую модель данных**.

### 3.2. Паттерн: Адаптация на границе системы

**Решение:** Преобразуем данные сразу после получения с сервера, до того как они попадут в наше приложение.

```typescript
// Где-то в useEffect при загрузке данных
const apiTodos = await fetchTodos();  // Получили с сервера

const appTodos = apiTodos.map(apiTodo => ({
  ...apiTodo,
  columnId: apiTodo.completed ? 'completed' : 'progress'
  // Теперь у нас есть columnId, а completed можем игнорировать
}));

setTodos(appTodos);
```

**Почему такое преобразование?**
- **Простое правило** - `completed: true` означает задача завершена → колонка "completed"
- **Обратная совместимость** - старые данные автоматически распределяются по двум базовым колонкам
- **Точка входа** - все данные проходят через это преобразование, дальше работаем только с `columnId`

### 3.3. Управление типами

Чтобы TypeScript помогал нам не путать API-модель и модель приложения, создаем отдельные типы:

```typescript
// В api/todos.ts
export interface TodoApiResponse {
  userId: number;
  id: number;
  title: string;
  completed: boolean;  // Так приходит с сервера
}

// В types/index.ts
export interface Todo {
  userId: number;
  id: number;
  title: string;
  columnId: string;  // Так используется в приложении
  user?: User;
}
```

Теперь:
- `fetchTodos(): Promise<TodoApiResponse[]>` - явно показывает, что возвращаем данные API
- Код, работающий с `Todo`, не компилируется, если пытаемся использовать `completed`
- TypeScript заставит нас сделать преобразование

**Важный принцип:** Граница системы (API calls) должна быть явной. Данные преобразуются на входе и выходе.

---

## Часть 4: Распределение задач по колонкам - выбор структуры данных

### 4.1. Задача: эффективный доступ к задачам колонки

У нас есть:
```typescript
todos: Todo[]  // Плоский массив всех задач
columns: Column[]  // Массив всех колонок
```

Нужно для каждой колонки получить её задачи для рендеринга. Какие есть варианты?

### 4.2. Вариант 1: Фильтрация на месте (наивный подход)

```typescript
{columns.map(column => (
  <TaskList
    tasks={todos.filter(t => t.columnId === column.id)}
  />
))}
```

**Анализ:**
- ✅ Простота - одна строка, понятная логика
- ❌ Производительность - фильтрация выполняется при каждом рендере
- ❌ Если 3 колонки и 100 задач - проходим по 100 задачам трижды = 300 итераций

### 4.3. Вариант 2: Функция с useCallback

```typescript
const getTasksByColumn = useCallback((columnId: string) => {
  return todos.filter(t => t.columnId === columnId);
}, [todos]);

// Использование
<TaskList tasks={getTasksByColumn(column.id)} />
```

**Анализ:**
- ✅ Мемоизация функции - ссылка не меняется при ререндерах
- ❌ Все еще фильтруем при каждом вызове
- ⚠️ `useCallback` сохраняет **функцию**, но не результат её выполнения

### 4.4. Вариант 3: Предварительная группировка с useMemo (оптимальный)

```typescript
const tasksByColumn = useMemo(() => {
  const grouped: Record<string, Todo[]> = {};

  // Инициализируем пустые массивы для каждой колонки
  columns.forEach(column => {
    grouped[column.id] = [];
  });

  // Один проход по всем задачам, распределяем по колонкам
  todos.forEach(task => {
    if (grouped[task.columnId]) {
      grouped[task.columnId].push(task);
    }
  });

  return grouped;
}, [todos, columns]);

// Использование
<TaskList tasks={tasksByColumn[column.id] || []} />
```

**Анализ:**
- ✅ Эффективность - один проход по задачам, результат кэшируется
- ✅ Пересчет только при изменении `todos` или `columns`
- ✅ O(n) сложность вместо O(n * m), где n - задачи, m - колонки
- ✅ Простой доступ к задачам любой колонки по ключу

**Почему именно `Record<string, Todo[]>`?**

Это объект (hash map), где:
- Ключ - ID колонки (`string`)
- Значение - массив задач этой колонки (`Todo[]`)

Пример структуры:
```typescript
{
  'progress': [task1, task2],
  'review': [task3],
  'completed': [task4, task5, task6]
}
```

Доступ к задачам - O(1) операция, очень быстро даже для больших данных.

### 4.5. Зачем инициализировать пустые массивы?

```typescript
columns.forEach(column => {
  grouped[column.id] = [];
});
```

Это защита от ошибок. Если колонка существует, но в ней нет задач:
- Без инициализации: `grouped['new-column']` → `undefined` → `.map()` вызовет ошибку
- С инициализацией: `grouped['new-column']` → `[]` → `.map()` работает, просто ничего не рендерит

Плюс мы гарантируем, что каждая колонка присутствует в объекте, даже пустая.

---

## Часть 5: Динамический рендеринг колонок

### 5.1. От статики к динамике

**Старый подход (статический):**
```typescript
<Stack direction="row">
  <TaskList title="Активные" tasks={activeTasks} ... />
  <TaskList title="Завершенные" tasks={completedTasks} ... />
</Stack>
```

Проблемы:
- Жестко закодировано количество колонок
- Нельзя добавить новую без изменения JSX
- Порядок определяется порядком написания кода

**Новый подход (динамический):**
```typescript
<Stack direction="row">
  {columns
    .sort((a, b) => a.order - b.order)
    .map(column => (
      <TaskList
        key={column.id}
        title={column.title}
        tasks={tasksByColumn[column.id] || []}
        ...
      />
    ))}
</Stack>
```

### 5.2. Ключевые моменты реализации

**Сортировка: `.sort((a, b) => a.order - b.order)`**

Это определяет визуальный порядок колонок слева направо. Без сортировки колонки могут отображаться в случайном порядке (порядок добавления в массив).

Работает так:
- Если `a.order < b.order` → результат отрицательный → `a` идет перед `b`
- Если `a.order > b.order` → результат положительный → `b` идет перед `a`
- Если равны → порядок не меняется

**Ключ: `key={column.id}`**

React требует уникальный `key` для элементов в массиве. Это критически важно для:
- **Эффективного обновления DOM** - React понимает, какой элемент изменился
- **Сохранения состояния компонента** - при изменении порядка колонки не пересоздаются заново
- **Предотвращения багов** - без ключа могут возникать проблемы с формами и анимациями

Используем `column.id`, потому что:
- Гарантированно уникален
- Не меняется при изменении порядка или названия
- Связан с данными (задачи ссылаются на этот же ID)

**Fallback: `|| []`**

```typescript
tasks={tasksByColumn[column.id] || []}
```

Защита от ситуации, когда колонка новая и в `tasksByColumn` для нее еще нет записи. Без fallback получим `undefined`, что вызовет ошибку при попытке `.map()` в `TaskList`.

---

## Часть 6: Перемещение задач между колонками

### 6.1. Семантика операции

Раньше была операция "переключить статус выполнения" (`toggleComplete`). Это имело смысл для boolean - инвертировать `true ↔ false`.

Теперь у нас множественное состояние, и операция становится "переместить задачу в другую колонку" (`moveTaskToColumn`). Это более общая операция:
- Перемещение из "В работе" в "На проверке"
- Перемещение из "На проверке" в "Завершено"
- Откат из "Завершено" в "В работе"

### 6.2. Реализация функции перемещения

```typescript
const moveTaskToColumn = useCallback(async (taskId: number, targetColumnId: string) => {
  const task = todos.find(t => t.id === taskId);
  if (!task) return;

  try {
    // Оптимистичное обновление - сразу меняем UI
    const updatedTodos = todos.map(t =>
      t.id === taskId ? { ...t, columnId: targetColumnId } : t
    );
    setTodos(updatedTodos);

    // Можно было бы отправить на сервер, но JSONPlaceholder не поддерживает кастомные поля
    // await updateTodo(taskId, { columnId: targetColumnId });
  } catch (error) {
    // В реальном приложении здесь был бы rollback
    console.error("Error moving task:", error);
  }
}, [todos]);
```

**Принцип "оптимистичного обновления" (Optimistic UI Update):**

Мы обновляем UI сразу, не дожидаясь ответа сервера. Это создает ощущение мгновенного отклика. Если запрос упадет - делаем rollback (откатываем изменения).

### 6.3. Обратная совместимость с чекбоксом

Старое поведение - чекбокс переключает задачу между "активна" и "завершена" - все еще имеет смысл для пользовательского опыта. Создаем обертку:

```typescript
const toggleTask = useCallback((taskId: number) => {
  const task = todos.find(t => t.id === taskId);
  if (!task) return;

  // Если задача завершена - вернуть в первую колонку
  // Если не завершена - переместить в "completed"
  const targetColumnId = task.columnId === 'completed'
    ? columns[0]?.id || 'progress'  // Безопасный доступ к первой колонке
    : 'completed';

  moveTaskToColumn(taskId, targetColumnId);
}, [todos, columns, moveTaskToColumn]);
```

**Логика выбора целевой колонки:**
- Если задача в "completed" → перемещаем в первую колонку (разумное предположение для "вернуть в работу")
- Если задача в любой другой колонке → перемещаем в "completed"
- Используем `columns[0]?.id` с fallback на 'progress' для безопасности

Это сохраняет привычное поведение чекбокса, но работает в новой системе.

---

## Часть 7: Добавление новых колонок

### 7.1. Генерация ID из названия

Когда пользователь создает колонку, он вводит название ("На проверке"). Но нам нужен программный ID. Стратегия:

```typescript
const generateColumnId = (title: string): string => {
  return title
    .toLowerCase()                // "На проверке" → "на проверке"
    .replace(/\s+/g, '-')         // "на проверке" → "на-проверке"
    .replace(/[^\w\-]/g, '');     // Убираем специальные символы
};
```

**Почему такое преобразование?**
- **URL-safe** - можно использовать в адресах
- **Читаемость** - "на-проверке" понятнее, чем генерированный UUID
- **Простота** - не требует внешних библиотек

**Проблема:** что если пользователь создаст две колонки "Задачи" и потом еще одну "Задачи"? ID будет одинаковый.

**Решение:** Проверка уникальности перед добавлением:

```typescript
const addNewColumn = useCallback((title: string) => {
  const id = generateColumnId(title);

  if (columns.some(col => col.id === id)) {
    // Обработка конфликта - показать ошибку или добавить суффикс
    setError('Колонка с таким названием уже существует');
    return;
  }

  const newColumn: Column = {
    id,
    title,
    order: columns.length  // Добавляем в конец
  };

  setColumns([...columns, newColumn]);
}, [columns]);
```

### 7.2. Альтернативные стратегии генерации ID

**UUID/GUID (универсальный, но нечитаемый):**
```typescript
import { v4 as uuid } from 'uuid';
const id = uuid();  // "550e8400-e29b-41d4-a716-446655440000"
```

Плюсы: гарантированная уникальность, работает в распределенных системах
Минусы: нечитаемо, сложно отлаживать

**Инкрементальный ID (простой, но хрупкий):**
```typescript
const id = `column-${columns.length + 1}`;  // "column-1", "column-2"
```

Плюсы: простота
Минусы: при удалении колонки возможны конфликты, не семантичный

**Рекомендация:** slug из названия с проверкой уникальности - баланс читаемости и надежности.

---

## Часть 8: Персистентность - сохранение колонок

### 8.1. Проблема: колонки теряются при перезагрузке

Если колонки хранятся только в `useState`, при обновлении страницы все пользовательские колонки исчезнут. Нужна **персистентность** - сохранение данных между сессиями.

### 8.2. Варианты хранения

**LocalStorage (браузер, синхронно):**
```typescript
// Сохранение
localStorage.setItem('columns', JSON.stringify(columns));

// Загрузка
const saved = localStorage.getItem('columns');
const columns = saved ? JSON.parse(saved) : defaultColumns;
```

Плюсы: простота, работает офлайн, не требует сервера
Минусы: только для текущего браузера, ограничение ~5-10 МБ, нет синхронизации между устройствами

**Backend API (сервер, асинхронно):**
```typescript
// Загрузка
const columns = await fetch('/api/user/columns').then(r => r.json());

// Сохранение
await fetch('/api/user/columns', {
  method: 'PUT',
  body: JSON.stringify(columns)
});
```

Плюсы: синхронизация между устройствами, неограниченное хранилище, можно делиться между пользователями
Минусы: требует бэкенд, не работает офлайн, сложнее реализовать

**Рекомендация для начинающих:** начните с LocalStorage, потом мигрируйте на бэкенд при необходимости.

### 8.3. Паттерн: синхронизация state с LocalStorage

```typescript
// Загрузка при инициализации (ленивая инициализация)
const [columns, setColumns] = useState<Column[]>(() => {
  const saved = localStorage.getItem('columns');
  if (saved) {
    try {
      return JSON.parse(saved);
    } catch {
      return defaultColumns;  // Fallback на случай поврежденных данных
    }
  }
  return defaultColumns;
});

// Сохранение при изменении
useEffect(() => {
  localStorage.setItem('columns', JSON.stringify(columns));
}, [columns]);
```

**Почему функция в `useState(() => ...)`?**

Это называется "ленивая инициализация" (lazy initialization). Функция выполняется **один раз** при монтировании компонента. Без нее:
```typescript
const [columns, setColumns] = useState(JSON.parse(localStorage.getItem('columns')))
```
Выражение `JSON.parse(...)` будет вычисляться **при каждом рендере**, даже если результат не используется.

**Обработка ошибок `try/catch`:**

LocalStorage может содержать поврежденные данные (ручное редактирование, несовместимая версия приложения). `JSON.parse` бросит исключение, и без `catch` приложение сломается. Лучше вернуться к дефолтным колонкам, чем упасть.

---

## Часть 9: Обновление формы создания задачи

### 9.1. Проблема статического Select

Форма создания задачи имеет выбор колонки:
```typescript
<Select value={newTaskColumnId} ...>
  <MenuItem value="progress">Активная</MenuItem>
  <MenuItem value="completed">Завершённая</MenuItem>
</Select>
```

Эти опции жестко закодированы. При добавлении новой колонки она не появится в списке.

### 9.2. Динамическая генерация опций

```typescript
<Select value={newTaskColumnId} onChange={(e) => setNewTaskColumnId(e.target.value)}>
  {columns.map(column => (
    <MenuItem key={column.id} value={column.id}>
      {column.title}
    </MenuItem>
  ))}
</Select>
```

Теперь опции генерируются из `columns`. Добавили колонку в state → она автоматически появляется в Select.

### 9.3. Выбор дефолтной колонки

```typescript
const [newTaskColumnId, setNewTaskColumnId] = useState<string>(
  columns[0]?.id || 'progress'
);
```

**Почему `columns[0]?.id`?**

Разумное предположение: новые задачи идут в первую колонку (обычно это "Новые" или "В очереди").

**Optional chaining `?.`:**

Защита от случая, когда `columns` пустой. Без `?` при `columns.length === 0` получим `Cannot read property 'id' of undefined`. С `?.` получим `undefined`, потом `|| 'progress'` вернет запасной вариант.

### 9.4. Синхронизация с сервером

Когда создаем задачу, JSONPlaceholder ожидает `completed: boolean`, но мы работаем с `columnId: string`. Адаптация:

```typescript
const createTask = async () => {
  // Отправляем на сервер в формате API
  const serverTask = await createTodo(
    newTaskTitle,
    newTaskColumnId === 'completed',  // Преобразуем columnId → completed
    newTaskUserId
  );

  // Локально добавляем с columnId
  const taskWithColumn = {
    ...serverTask,
    columnId: newTaskColumnId
  };

  setTodos([taskWithColumn, ...todos]);
};
```

**Принцип:** на границе системы (API call) преобразуем данные между форматами. Внутри приложения всегда работаем с `columnId`.

---

## Часть 10: Архитектурные паттерны и best practices

### 10.1. Разделение concerns (separation of concerns)

Хорошая архитектура разделяет ответственность:

- **Компонент-контейнер** (`TasksFetch`) - управление состоянием, бизнес-логика, API-вызовы
- **Презентационные компоненты** (`TaskList`, `Task`) - только отображение, получают все через props
- **API слой** (`api/todos.ts`) - работа с сервером, знает о деталях HTTP
- **Типы** (`types/index.ts`) - контракты данных, используются везде

Не смешивайте: `Task` не должен делать API-вызовы, `TasksFetch` не должен содержать детали верстки.

### 10.2. Нормализация данных

Мы используем **нормализованную** структуру данных:
```typescript
columns: Column[]      // Колонки
todos: Todo[]          // Задачи с columnId
tasksByColumn: {...}   // Вычисляется на лету
```

Альтернатива - **денормализованная**:
```typescript
columns: Array<{
  id: string,
  title: string,
  tasks: Todo[]  // Задачи внутри колонки
}>
```

**Почему нормализация лучше:**
- Единственный источник истины для каждой сущности
- Проще обновлять (изменить задачу = изменить один элемент массива `todos`)
- Нет дублирования данных
- Легче поддерживать консистентность

**Когда денормализация имеет смысл:**
- Данные read-only (не меняются)
- Производительность критична, и пересоздание структуры дорого
- Данные естественно иерархичны (дерево комментариев)

Для нашего случая - нормализация оптимальна.

### 10.3. Мемоизация - когда и зачем

React предоставляет `useMemo` и `useCallback` для оптимизации. Но не нужно мемоизировать все подряд.

**Используйте `useMemo` когда:**
- Вычисление дорогое (фильтрация больших массивов, сложные расчеты)
- Результат используется как зависимость в других хуках
- Результат передается как prop в мемоизированный компонент

**НЕ используйте `useMemo` когда:**
- Вычисление простое (создание объекта, простая арифметика)
- Экономия меньше стоимости мемоизации (хранение, сравнение зависимостей)

В нашем случае:
```typescript
const tasksByColumn = useMemo(...)  // ✅ Оправдано - итерация по массивам
const firstName = useMemo(() => user.name.split(' ')[0], [user])  // ❌ Избыточно
```

### 10.4. Иммутабельность

React требует иммутабельных обновлений state. Вместо мутации создаем новые объекты:

```typescript
// ❌ Мутация - React не увидит изменение
todos[0].columnId = 'completed';
setTodos(todos);

// ✅ Иммутабельное обновление
setTodos(todos.map(t =>
  t.id === taskId ? { ...t, columnId: 'completed' } : t
));
```

**Почему это важно:**
- React сравнивает ссылки для определения изменений
- При мутации ссылка не меняется → React думает, что ничего не изменилось → не перерисовывает
- Иммутабельность предотвращает трудноуловимые баги

---

## Часть 11: Возможные расширения системы

После базовой реализации можно добавить:

### 11.1. Drag and Drop

Библиотека `@hello-pangea/dnd` (или `dnd-kit`) для перетаскивания задач между колонками:

```typescript
<DragDropContext onDragEnd={handleDragEnd}>
  {columns.map(column => (
    <Droppable droppableId={column.id}>
      {provided => (
        <div ref={provided.innerRef} {...provided.droppableProps}>
          {tasksByColumn[column.id].map((task, index) => (
            <Draggable draggableId={task.id.toString()} index={index}>
              {/* Task component */}
            </Draggable>
          ))}
        </div>
      )}
    </Droppable>
  ))}
</DragDropContext>
```

### 11.2. Фильтры и группировка

Добавить фильтрацию задач по:
- Пользователю (исполнителю)
- Дате создания
- Приоритету (если добавить это поле)

```typescript
const visibleTasks = useMemo(() => {
  let filtered = todos;

  if (selectedUserId) {
    filtered = filtered.filter(t => t.userId === selectedUserId);
  }

  return filtered;
}, [todos, selectedUserId]);
```

### 11.3. Кастомные свойства колонок

Расширить `Column` дополнительными свойствами:
```typescript
interface Column {
  id: string;
  title: string;
  order: number;
  color?: string;        // Цвет колонки
  limit?: number;        // Лимит задач (для WIP limits в Kanban)
  isCollapsed?: boolean; // Свернута ли колонка
}
```

### 11.4. Backend API для колонок

Создать эндпоинты:
- `GET /api/user/columns` - получить колонки пользователя
- `POST /api/user/columns` - создать колонку
- `PATCH /api/user/columns/:id` - обновить колонку
- `DELETE /api/user/columns/:id` - удалить колонку

Это позволит синхронизировать колонки между устройствами.

---

## Резюме: Ключевые концепции

**1. Модель данных определяет возможности приложения**
- Boolean → 2 состояния
- String/Enum → N состояний
- Выбор модели данных - первое архитектурное решение

**2. Нормализация упрощает управление состоянием**
- Каждая сущность в одном месте
- Связи через ID
- Проще обновлять и поддерживать консистентность

**3. Граница системы требует адаптации данных**
- API использует другую модель → преобразуем на входе/выходе
- Разные типы для API и приложения помогают избежать ошибок

**4. Динамический рендеринг вместо жестко заданного**
- `array.map()` для создания компонентов
- Изменение данных автоматически обновляет UI
- Масштабируемость без изменения кода

**5. Оптимизация через правильные паттерны**
- `useMemo` для дорогих вычислений
- Группировка данных для эффективного доступа
- Иммутабельные обновления для корректной работы React

---

## Дальнейшее изучение

**Рекомендуемые темы для углубления:**

1. **State Management** - при росте приложения рассмотрите Zustand или Redux Toolkit
2. **TypeScript Advanced Types** - Discriminated Unions, Generics для более типобезопасного кода
3. **React Performance** - React.memo, виртуализация длинных списков (react-window)
4. **API Design** - REST best practices, GraphQL как альтернатива
5. **Testing** - unit тесты для функций, integration тесты для компонентов

Удачи в реализации! Экспериментируйте с кодом, пробуйте разные подходы - это лучший способ понять, почему определенные решения работают лучше других.
